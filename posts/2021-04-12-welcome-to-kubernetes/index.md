---
authors:
- jwher
description: Welcome To Kubernetes
slug: welcome-to-kubernetes
tags:
- tech
- kubernetes
- docker
title: 쿠버네티스 기본 개념과 필요성
---

![kubernetes](/img/logos/kubernetes.svg)
*쿠버네티스 세계에 오신 걸 환영합니다!*

이 글은 쿠버네티스 창시자인 **브렌던 번스** 의 책 Managing Kubernetes를 참고하여 다시 작성했습니다.  
<!--truncate-->

# 목차
* [쿠버네티스란?](#쿠버네티스란?)
* [쿠버네티스의 필요성](#쿠버네티스의-필요성)
* [쿠버네티스 개념](#쿠버네티스-개념)

<br/>

## 쿠버네티스란?

쿠버네티스는 컨테이너 애플리케이션을 배포하기 위한 **오케스트레이터**입니다.
도커와 컨테이너를 모르고 쿠버네티스를 먼저 접하셨다면,
[이 글](https://jwher.github.io/2021-06-19-welcome-to-docker/) 을 먼저 읽는 것을 추천합니다.

컨테이너는 많은 이점을 지닙니다. 저는 <u>개발 환경 분리</u>을 가장 큰 이점이라 생각하는데요,
**구글**은 대규모 시스템(*ex: youtube*)를 운영하며 일주일에 20억개의 컨테이너를 배포한다고 합니다.  

이런 작업을 사람이 일일히 할 순 없겠죠.
구글은 컨테이너 기반 시스템을 오랜 기간동안 운영하며 쿠버네티스를 개발했으며,
2015년 오픈소스로 공개된 후 현재는 MSA(Micro Service Architecture)의 표준이라 할 정도로 널리 쓰이고 있습니다.

<br/>

## 쿠버네티스의 필요성

앞서 살펴봤듯이 쿠버네티스는 컨테이너 애플리케이션을 배포하는 오케스트레이션 API를 제공합니다.
하지만 배포만 잘한다고 뛰어난 오케스트레이터가 될 순 없을 것입니다.
쿠버네티스는 오류가 있는 애플리케이션을 복구하는 자가 재해 복구 알고리즘을 제공합니다.
또한, 서비스의 여러 레플리카 간에 트래픽을 쉽게 분산할 수 있는 로드 밸런서를 제공하고,
소프트웨어의 무중단 업데이트를 쉽게 수행할 수 있게 도와줍니다.

이 외에도 쿠버네티스는 보안, 문제 대응, 시스템 확장을 제공합니다.
하지만 글이 복잡해지니 지금은 기본적인 개념만 다루겠습니다.

<!--
운영자(Engineer)가 아무리 날고 기어도, *고장난* 서버가 스스로 고쳐지게 할 순 없다.  
하지만 실제 운영중에 소프트웨어, 커널 시스템, 물리적 오류로 서버는 빈번하게 고장난다.  
또한, 다수 서버에서 배포작업은 *어렵고* 운영자가 단순 노동자로 변하게 한다.

하지만 운영자를 위한 개발자들이 있었으니,  
kubernetes는 컨테이너화된 어플리케이션을 자동으로 배포, 스케일링 및 관리해주는 오픈소스 시스템이다.
-->

> ![container](container.png)
> 수많은 컨테이너를 혼자 싣긴 힘들겠죠 :relaxed:

<br/>

## 쿠버네티스 개념

### 선언적 구성 *declarative configuration*

선언宣言 이란 무엇일까요?  
> 吾等은 玆에 我 朝鮮의 獨立國임과 朝鮮人의 自主民임을 宣言하노라
> ―기미 독립 선언서

일제 강점기, 민족대표 33명은 1919년 3월 1일에 독립을 선언합니다. 이처럼 선언은 '널리 펴서 말하는 것'을 말합니다.

너무 거창했나요?
쿠버네티스에서 운영자는 ```이 앱을 그 서버에서 3개를 실행시키고 싶어``` 라고 선언할 수 있습니다.
이런 선언문은 쿠버네티스가 이해할 수 있게 구조화된 YAML, JSON 파일으로 이루어집니다.  

이전까지는 운영자가 원하는 상태로 배포를 하기 위해서 여러 명령어를 작성했었습니다.
선언적 구성은 명령어의 숫자를 줄이는 것보다 더 좋은 장점이 있는데요,
운영자가 선언한 이상적인 상태를 이해하기 때문에 현재 상태를 관찰하고 스스로 수정과 복구를 할 수 있다는 것입니다.  

이런 작업을 수행하는 것은 쿠버네티스 컨트롤러입니다.
컨트롤러는 선언문과 현재 상태를 비교해 상태를 유지시킵니다.
상태를 관찰하는데 어려움은 *어떤* 그룹을 관찰할지 결정하는 것인데요,
다음 단락을 봅시다.
<details>
<summary>TL;DR</summary>
<div markdown="1">

자연어로 실행되는 프로그래밍 언어를 꿈꿔온 저에겐 흥미있는 개념이였는데요,

학부에서 프로그래밍 언어를 들은 사람은
haskell, Erlang과 같은 함수형, Prolog와 같은 논리형 언어의 패러다임을 선언적 언어라 함을 기억할 것입니다.
좀더 친숙한 C, Java, python이 명령적(imperative) 언어는
내가 원하는 상태로 만드는 *과정*을 작성하지만, 선언적 언어는 원하는 *상태*를 작성하게 됩니다.  

명령형 언어는 목적을 달성하기 위한 방법을 최적화 할 수 있다는 장점이 있을 것입니다.
선언적 언어는 언듯 보면 *비효율*적일 것 같습니다.
특히 SQL 쿼리 최적화 작업, C보다 밑의 어셈블리 최적화를 진행하시는 분이라면 더더욱 이해하기 힘들 것입니다.  

그렇다면 선언형 언어의 장점은 무엇일까요?  
바로 목적을 이루는데 강건한(robust) 방법을 제공한다는 것입니다.
어려운 말들을 더 늘어놓자면 어떤 환경에서 실행시켜도 똑같은 결과를 주는 멱등성이 성립한다고 할까요?

컴퓨팅 성능의 향상과 함께 빠르게 개발이 가능한 파이썬과 같은 인터프리터 언어가 유행하게 된 것 처럼
우주선 프로그래밍에 쓰이던 선언형 언어도 유행하게 되는 날을 생각해 봅니다.
</div>
</details>

<br/>

### 암시적/동적 그룹화

일상속에서 접하기 쉬운 그룹은 *목록*으로 구성되어 있습니다.
> 카카오톡 채팅방은 정해진 목록으로 참가자 그룹을 인식합니다.  
> 친구 광호, 민수, 우철이를 채팅방에 초대해서 그룹을 만들었습니다.

새롭게 채팅방을 만들려고 하면 참가자 *목록*을 작성해 주어야 합니다.
이를 명시적/정적 그룹화라고 합니다.
<br/>

다른 상황을 생각해 볼까요?   
고등학교 체육시간, 갑작스럽게 축구를 하게 되어 반을 두 팀으로 나누게 되었습니다.
> 출석번호 홀수는 왼쪽, 짝수는 오른쪽 팀이야!

다른 반이 축구팀에 합류해도 어느 그룹에 들어갈지 알 수 있겠네요!  
이를 암시적/동적 그룹화라고 합니다.

쿠버네티스도 라벨(레이블)을 사용하여 그룹을 암시적으로 표현합니다.

<br/>  

## kubernetes 설계 원칙
*새삼스럽게 쿠버네티스만 그런건 아닙니다...*

### Unix 철학

벨 연구소에서 Unix 개발을 주도한 켄 톰프슨이 고안한 것으로,
최소주의적인 모듈 방식의 소프트웨어 개발 방식을 말합니다.

유닉스 철학은 1978년 더글러스 매클로이가, 1994년 피터 H. 살루스가 다시 한번 정리하는데요,  
내용은 다음과 같습니다.
* Write programs that do one thing and do it well.  
  (한가지 기능만, 잘 수행하게)  
* Write programs to work together.  
  (함께 작동할 수 있게)  
* Write programs to handle text streams, because that is a universal interface.  
  (텍스트 스트림을 처리할 수 있게, 대중적인 인터페이스니까)  

현재 대부분 지향하는 단순하고 짧고 명료하고 모듈 방식의 확장 가능한 코드 또한 유닉스 철학에서 영향을 받았다고 할 수 있습니다.

### Api 기반 상호 작용

API(Application Programming Interface)는 말 그대로 응용 프로그램에서 사용할 수 있도록,
운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.  

쿠버네티스에선 중앙 집중 API를 사용해 수많은 애플리케이션이 서로 상호작용 합니다.
시스템의 어떤 부분도 특권을 갖고 직접 접근할 수 없다는 점은 교체와 추가가 자유로운 장점을 제공합니다.
따라서 쿠버네티스는 소프트웨어가 업그레이드 되며 발생하는 버전 호환 문제를 쉽게 해결할 수 있습니다.

<br/>

## 그래서 어떻게 작동하는데?
[다음 글](/posts/kubernetes-architecture)에서 쿠버네티스 구성요소와 작동방식을 이어서 설명합니다.  

아래는 2018년 구글 클라우드 해커톤 자료입니다;)  
[2018 Cloud Hackathon Tech Session - Kubernetes](https://www.youtube.com/watch?v=rdyUAduXi48)

<br/>

## Tips
kubernetes를 줄여 k8s라고 합니다. 이유는 긴 단어를 줄일 때 글자의 개수를 적는게 관례였기 때문이라고 하네요:D
[K8s as an abbreviation results from counting the eight letters between the "K" and the "s".](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)  

~~직접 한번 세보자...~~

<br/>

## Reference  

[[Redhat]쿠버네티스란?](https://www.redhat.com/ko/topics/containers/what-is-kubernetes)  
[[공식]쿠버네티스란 무엇인가?](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/)  
[[위키]유닉스 철학](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%B2%A0%ED%95%99)  
[[위키]API](https://ko.wikipedia.org/wiki/API)



[container-definition]: https://cloud.kt.com/portal/user-guide/education-eduadvanced-edu_adv_2

<!--
구성요소
api 서버
스케줄러
설치[x]/보안/인증인가/네트워킹
모니터링
복구
확장
-->
