<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.20">
<link rel="alternate" type="application/rss+xml" href="/en/posts/rss.xml" title="JWHer Tech Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/en/posts/atom.xml" title="JWHer Tech Blog Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-XHBVCY40VB","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><title data-rh="true">7가지 동시성 모델 2(스레드와 락) | JWHer Tech Blog</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jwher.github.io/en/posts/concurrency-models-2"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="7가지 동시성 모델 2(스레드와 락) | JWHer Tech Blog"><meta data-rh="true" name="description" content="Seven Concurrency Models in Seven Weeks 2"><meta data-rh="true" property="og:description" content="Seven Concurrency Models in Seven Weeks 2"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-12-14T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/jwher"><meta data-rh="true" property="article:tag" content="tech,distributed computing"><link data-rh="true" rel="icon" href="/en/img/logo.svg"><link data-rh="true" rel="canonical" href="https://jwher.github.io/en/posts/concurrency-models-2"><link data-rh="true" rel="alternate" href="https://jwher.github.io/en/posts/concurrency-models-2" hreflang="en"><link data-rh="true" rel="alternate" href="https://jwher.github.io/posts/concurrency-models-2" hreflang="kr"><link data-rh="true" rel="alternate" href="https://jwher.github.io/posts/concurrency-models-2" hreflang="x-default"><link rel="stylesheet" href="/en/assets/css/styles.03262d91.css">
<link rel="preload" href="/en/assets/js/runtime~main.6d454c49.js" as="script">
<link rel="preload" href="/en/assets/js/main.3c483c9e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/en/"><div class="navbar__logo"><img src="/en/img/logo.svg" alt="Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/en/img/logo.svg" alt="Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title text--truncate">JWHer Tech Blog</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/en/posts">Posts</a><a class="navbar__item navbar__link" href="/en/categories">Categories</a><a href="https://github.com/jwher" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link icon-github"></a><a href="https://www.linkedin.com/in/jwher" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link icon-linkedin"></a><a href="https://www.instagram.com/jwher96" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link icon-instagram"></a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_dLyj"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="posts__header_mMDK"><div class="filter_lpre"></div><h2 class="presentation__title">Posts</h2><h6 class="presentation__subtitle">Let thine heart retain my words: Keep my commandments, and live.</h6></div><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_TMXw thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_V4zb margin-bottom--md">All posts</div><ul class="sidebarItemList_uHd5 clean-list"><li class="sidebarItem_spIe"><a aria-current="page" class="sidebarItemLink_eqrF sidebarItemLinkActive_XZSJ" href="/en/posts/concurrency-models-2">7가지 동시성 모델 2(스레드와 락)</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/concurrency-models-1">7가지 동시성 모델 1(소개)</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/hidden-technical-debt">머신러닝에 숨은 기술 부채</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/api-design-for-long-jobs">오래걸리는 API 설계</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/deep-learning-on-a-data-diet">학습에 중요한 데이터 찾기</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/ngrx">NGRX 반응형 웹을 위한 상태 관리</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/power-series">다양한 급수</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/build-opencv-with-java">Build OpenCV with Java</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/binomial-theorem">이항정리 - π값을 구하는 법</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/pytorch-in-m1">Pytorch in M1</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/agile">Agile</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/first-post-with-docusaurus">First post with docusaurus</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/ensemble-methods">Ensemble Methods</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/uncertainty-estimation">Uncertainty Estimation</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/Intelligent-Computer-Vision-1">Intelligent Computer Vision 1</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/kubernetes-architecture">쿠버네티스 아키텍처</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/kubeflow-guide">Kubeflow Guide</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/sagemaker">Sagemaker</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/blog-tech-map">Blog Tech Map</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/cncf">Cncf</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/envoy">Envoy</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/istio">Istio</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/dex">Dex</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/k8s-tip-configmap">K8S Tip Configmap</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/golang-setup">Golang Setup</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/docker-shared-volume">Docker Shared Volume</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/variable-autoencoder">Variable Autoencoder</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/k8s-tip-pv-terminating">K8S Tip Pv Terminating</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/free-wildcard-dns">Free Wildcard Dns</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/install-harbor">Install Harbor</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/install-helm">Install Helm</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/github-issue">Github Issue</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/k8s-tip-rollback">K8S Tip Rollback</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/k8s-tip-expose-service">K8S Tip Expose Service</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/uuid">Uuid</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/deploying-ml-model-on-kubernetes-nuclio">Deploying Ml Model On Kubernetes Nuclio</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/kubeflow-visualization-2">Kubeflow Visualization 2</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/linux-disk-free">Linux Disk Free</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/welcome-to-docker">Welcome To Docker</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/welcome-to-kubeflow">Welcome To Kubeflow</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/minio">Minio</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/k8s-tip-nodeselector">K8S Tip Nodeselector</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/information-theory">Information Theory</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/kubeflow-visualization-1">Kubeflow Visualization 1</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/nuclio">Nuclio 개념과 아키텍처</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/kubernetes-usage">자주쓰는 쿠버네티스 명령어</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/blog-essay">나에게 필요한 연재에 대해</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/alphapose">Alphapose 논문 리뷰와 사용</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/update-blog">지킬 블로그 업데이트</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/install-tar.gz">타르(tar) 파일 설치하기</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/install-kubeflow">쿠브플로우를 설치하는 다양한 방법</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/virtualbox-with-no-gui">GUI 없이 버추얼박스 사용하기</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/install-docker">나에게 필요한 도커 설치하기</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/install-kubernetes">나에게 필요한 쿠버네티스 설치하기</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/welcome-to-kubernetes">쿠버네티스 기본 개념과 필요성</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/en/posts/first-post">First Post with Jekyll</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_uMeh" itemprop="headline">7가지 동시성 모델 2(스레드와 락)</h1><div class="blogPostData_Vfxe margin-vert--md"><time datetime="2022-12-14T00:00:00.000Z" itemprop="datePublished">December 14, 2022</time> · <!-- -->19 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><a href="https://github.com/jwher" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/jwher.png" alt="Jeongwon Her"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/jwher" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Jeongwon Her</span></a></div><small class="avatar__subtitle" itemprop="description">MLOps Engineer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p><img loading="lazy" alt="concurrency" src="/en/assets/images/ford-model-t-48420c1c3827d5d9e882499e160fc44f.jpeg" width="540" height="360" class="img_E7b_"><br>
<em>이 글은 Paul Butcher의 Seven Concurrency Models in Seven Weeks을 읽고 작성했습니다</em>  </p><p>Threads-and-locks programming is like a Ford Model T</p><h1>The Simplest Thing That Could Possibly Work</h1><p>Thread와 Lock은 하드웨어가 실제로 동작하는 것에 조금 더 형식을 부여한 것입니다.
이는 너무 간단하기 때문에, 강한 강점과 강한 약점을 같게 합니다.</p><p>Thread와 Lock은 목표를 달성하기에 작은 제약조건만 요구합니다.
하지만 실력없는 프로그래머한텐 처음부터 제대로 작동하게 만들기 어렵고,
심지어 관리하기 힘들게 만들어 거의 어떤 도움도 주지 못합니다.</p><p>이 글에선 자바를 통해 threads-and-locks 프로그래밍을 할 것입니다.
하지만, 원리는 thread를 지원하는 어떤 언어든 적용 가능합니다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="day-1-mutual-exclusion-and-memory-models">Day 1: Mutual Exclusion and Memory Models<a class="hash-link" href="#day-1-mutual-exclusion-and-memory-models" title="Direct link to heading">​</a></h2><p>동시성 프로그래밍을 전혀 해보지 않은게 아니라면,
당신은 <em>mutual exclusion</em>에 대한 컨셉에 익숙할 것입니다.
lock을 사용하여 한 스레드만 데이터에 접근 가능합니다.</p><p>또한, mutual exclusion이 <em>race conditions</em>와 <em>deadlocks</em>로 잘못될 수 있다는 것에 익숙할 것입니다.
이것에 대해 더 자세히 다룰 것이지만, 더 기본적인 shared memory를 다루는데에 더 걱정해야 합니다.
race condition과 deadlock이 이상한 행동을 보일 수 있다고 생각하면,
shared memory가 얼마나 기괴해질 수 있는지 기다려보세요.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="creating-a-thread">Creating a Thread<a class="hash-link" href="#creating-a-thread" title="Direct link to heading">​</a></h3><p>자바의 기본적인 동시성 단위는 <em>thread</em>입니다.
이름에서 알 수 있다시피 하나의 스레드 제어를 대표합니다.
스레드는 다른 스레드들과 공유메모리를 통해 통신합니다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorld {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread myThread = new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Hello from new thread&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        myThread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.yield();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Hello from main thread&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        myThread.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 코드는 하나의 스레드 인스턴스를 생성하고 시작합니다.
이 시점에서, 스레드의 <code>run()</code> 메소드가 남은 <code>main()</code>과 함께 동시적으로 실행됩니다.
마지막으로 <code>join()</code>이 모든 스레드가 종료될 때 까지 기다립니다.
(이는 <code>run()</code>이 return하면 수행됩니다.)</p><p>다음 결과를 얻거나</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">Hello from main thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello from new thread</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>대신 이런 결과를 얻을 수 있습니다.</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">Hello from new thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello from main thread</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이는 어떤 스레드가 <code>println()</code>을 받는가에 따라 다릅니다.
이런 타이밍에 대한 의존성은 멀티스레드 프로그래밍을 어렵게 만드는 원인입니다.
코드를 한번 실행시켰을 때 동작이 일관성을 보장한다고 할 수 없기 때문입니다.</p><details class="details_lb9f alert alert--info details_BAp3" data-collapsed="true"><summary>왜 `Thread.yield`를 사용하나요?</summary><div><div class="collapsibleContent_i85q"><p>Java documentation에 따르면 <code>yeild()</code>는</p><blockquote><p>a hint to the scheduler that the current thread is willing to yield its current use of a processor.</p></blockquote><p>이 호출이 없다면, 새 스레드의 시작 오버헤드 때문에 메인 스레드가 거의 확정적으로 <code>println()</code>을 처음으로 받을 수 있습니다.
(하지만, 보장되는것은 아닙니다)</p><p>이를 <code>Thread.sleep(1)</code>로 바꾸면 어떻게 될까요?</p></div></div></details><h3 class="anchor anchorWithStickyNavbar_mojV" id="our-first-lock">Our First Lock<a class="hash-link" href="#our-first-lock" title="Direct link to heading">​</a></h3><p>여러 스레드가 공유 메모리에 접근하면, 서로의 발을 밟을 수 있습니다.
<em>lock</em>을 사용하여 한 시점에 한 스레드만 접근가능하게 하여 <em>mutual exclusion(상호배제)</em>함으로서 회피할 수 있습니다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public class Counting {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        class Counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            private int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void increment() { ++count; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public int getCount() { return count; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Counter counter = new Counter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        class CountingThread extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int x = 0; x &lt; 10000; ++x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    counter.increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountingThread t1 = new CountingThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountingThread t2 = new CountingThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start(); t2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.join(); t2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(counter.getCount());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 코드를 돌린다면, 매번 다른 값을 얻을 것입니다.
이는 연산할 때 타이밍이 연관되면서, 두 스레드간 <code>Counter</code>의 <code>count</code>멤버에 <em>race condition</em>이 발생했기 때문입니다.</p><p>이런 결과에 놀랐다면, 자바 컴파일러가 <code>++count</code>에서 생성하는 바이트코드를 생각해 봅시다.</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">getfield #2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iconst_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iadd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">putfield #2</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>JVM 바이트코드에 익숙하지 않더라도 <code>getfield</code>에서 <code>count</code> 값을 가져오고
<code>iconst_1</code>는 따라오는 <code>iadd</code>를 통해 1을 더합니다.
<code>putfield</code>는 다시 값을 <code>count</code>에 작성하게 됩니다.
이 패턴은 <em>read-modify-write</em>로 흔히 알려져 있습니다.</p><p>해결법은 <code>count</code>에 <em>synchronize</em> 엑세스를 주는 것입니다.
그 방법 중 하나는 모든 자바 객체에 본질적인 lock을 사용하며 <code>increment()</code>를 동기화 시키는 것입니다.
(<em>mutex</em>, <em>monitor</em>, <em>critical section</em>으로도 들어봤을 것입니다.)</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">class Counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;   public synchronized void increment() { ++count; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getCount() { return count; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이제 <code>increment()</code>는 호출할때 <code>Counter</code>의 오브젝트 락을 요구하고, 반환할때 해제합니다.
따라서 한 스레드만 한 때에 함수 바디를 실행할 수 있습니다.
다른 스레드가 호출하면 락이 해제될 때까지 <em>block</em> 됩니다.
(이후에 <code>java.util.concurrent.atomic</code> 패키지가 락을 사용하는 대신 좋은 대안을 제공하는것을 보입니다)</p><p>매번 20000이라는 결과를 얻기에 이제 충분합니다!
하지만, 이 코드에도 약간의 버그가 남아있습니다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="mysterious-memory">Mysterious Memory<a class="hash-link" href="#mysterious-memory" title="Direct link to heading">​</a></h3><p>이 코드는 어떤 결과를 낼까요?</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public class Puzzle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static boolean answerReady = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int answer = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static Thread t1 = new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            answer = 42;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            answerReady = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static Thread t2 = new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (answerReady)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;The meaning of life is: &quot; + answer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;I don&#x27;t know the answer&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start(); t2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.join(); t2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>&quot;race condition&quot;을 생각하고 계셨다면, 정답입니다!
어떤 스레드가 먼저 실행될지 순서에 따라 meaning of life을 알 수 있을지 다릅니다.
하지만 우리가 볼 수 있는 다른 결과가 있습니다.</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">The meaning of life is: 0</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>어떻게 <code>answer</code>가 <code>answerReady</code>가 <code>true</code>가 되기전에 0일 수 있을까요?
이는 6-7번째 줄에서 우리에 발밑에서 일어나는 일 때문입니다.</p><ul><li>컴파일러가 코드를 재정렬하며 정적으로 최적화하게 허용되었습니다</li><li>JVM이 코드를 재정렬하여 동적으로 최적화하게 허용되었습니다.</li><li>하드웨어가 그것들을 재정렬하여 성능을 향상시킬 수 있게 허용되었습니다.</li></ul><p>가끔 우리 스레드에 보이지 않는 것들이 영향을 미치기도 합니다. <code>run()</code>을 다시 작성했다고 상상해 봅시다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!answerReady)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;The meaning of life is: &quot; + answer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 프로그램은 <code>answerReady</code>가 <code>true</code>가 되지 않기 때문에 절대 끝나지 않을 수 있습니다.</p><p>불행하게도 최근의 성능 향상은 이런 최적화를 통해 이루어졌기 때문에, 이 결과를 다뤄야만 합니다.
확실하게 모든것에 자유로울 순 없지만, 어떤것에 의지하고 의지하지 말아야 할지 알아야 합니다.
따라서 자바 메모리 모델이 들어오게 되었습니다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="memory-visibility">Memory Visibility<a class="hash-link" href="#memory-visibility" title="Direct link to heading">​</a></h3><p>자바 메모리 모델은 하나의 스레드를 통해 메모리 변화가 일어나면 다른 스레드에 <em>visible</em> 하도록 정의되었습니다. <a href="#1java-memory-model">[1]</a>
결론은 읽기 쓰기에 synchronization을 사용하지 않는 한 보장할 수 없음을 나타냅니다.</p><p>중요한 점은 두 스레드 모두 synchronization이 필요하다는 것을 쉽게 놓친다는 것입니다.</p><p>멀티스레드 프로그램이 잘못될 수 있는 일반적인 두 방법인
race condition과 memory visibility를 살펴보았으니 세번째로 deadlock을 살펴봅시다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="multiple-locks">Multiple Locks<a class="hash-link" href="#multiple-locks" title="Direct link to heading">​</a></h3><p>앞선 단락을 다 읽었다면 멀티스레드 세계에서 모든 메소드가 동기화되어야 한다고 생각한다면 용서받을 것입니다.
하지만 이는 쉽지 않습니다.</p><p>첫째로 끔찍하게 비효율적입니다.
모든 메소드가 동기화된다면 대부분의 시간을 block되는데 사용할 것입니다.
하지만 이는 걱정 중 하나일 뿐입니다.
하나 이상의 락이 있다면 스레드가 데드락에 걸릴 기회를 만드는 것입니다.</p><p>학술논문에서 동시성에 대해 자주 사용되는 &quot;식사하는 철학자&quot; 문제를 통해 deadlock을 보일 것입니다.
다섯명의 철학자가 원탁에 앉은 것을 상상해 보세요.
테이블에는 5개의 젓가락(10개가 아닙니다)이 다음과 같이 놓여있습니다.</p><p><img loading="lazy" alt="dinning-philosophers" src="/en/assets/images/dinning-philosophers-dd1641278f6fa0b0efa9c7af5078101b.png" width="414" height="372" class="img_E7b_"></p><p>철학자들은 배고프다고 생각할 수 있고, 배고프면 양쪽의 젓가락을 잡아 잠시 식사합니다.
다 먹으면 젓가락을 다시 내려놓습니다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">class Philosopher extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Chopstick left, right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Random random;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Philosopher(Chopstick left, Chopstick right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.left = left; this.right = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    random = new Random();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while(true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(random.nextInt(1000));     // Think for a while</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized(left) {                    // Grab left chopstick </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          synchronized(right) {                 // Grab right chopstick </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(random.nextInt(1000)); // Eat for a while</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch(InterruptedException e) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>다섯명을 동시에 설정하면, 몇시간정도 행복하게 작동하다 어느 순간 모두 멈추게 됩니다.
잠깐 생각해보면, 모든 철학자가 같은 때에 먹기를 결심할때 왼쪽의 젓가락을 잡고
오른쪽을 잡으려는 순간, 모두가 한 젓가락을 잡고 자신의 오른쪽에 젓가락을 기다리느라 멈춰있게 됨을 알 수 있습니다.
Deadlock</p><p>행복하게도 데드락에 걸리지 않도록 보장하는 규칙이 있습니다.
항상 전역으로 고정된 순서대로 락을 얻는 것입니다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">class Philosopher extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; private Chopstick first, second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Random random;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Philosopher(Chopstick left, Chopstick right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;   if(left.getId() &lt; right.getId()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;     first = left; second = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;   } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;     first = right; second = left;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    random = new Random();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while(true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(random.nextInt(1000));     // Think for a while</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;       synchronized(first) {                   // Grab first chopstick </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;         synchronized(second) {                // Grab second chopstick </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(random.nextInt(1000)); // Eat for a while</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch(InterruptedException e) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>left</code>와 <code>right</code> 젓가락을 잡는 대신, <code>first</code>와 <code>second</code>를 젓가락 id 순서대로 잡으면서 락 없이 행복하게 계속될 수 있습니다.
<em>(젓가락 1번과 5번 사이에 앉은 사람이 왼쪽 대신에 오른쪽을 먼저 살펴보며 해결됩니다)</em></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-perils-of-alien-methods">The Perils of Alien Methods<a class="hash-link" href="#the-perils-of-alien-methods" title="Direct link to heading">​</a></h3><p>큰 프로그램은 종종 <em>listeners</em>를 만들어 모듈과 디커플링합니다.
여기에 예제로 <em>ProgressListeners</em>가 등록될 수 있는 클래스가 있습니다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">class Downloader extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private InputStream in;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private OutputStream out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ArrayList&lt;ProgressListener&gt; listeners;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Downloader(URL url, String outputFilename) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        in = url.openConnection().getInputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out = new FileOutputStream(outputFilename);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        listeners = new ArrayList&lt;ProgressListener&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void addListener(ProgressListener listener) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        listeners.add(listener);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void removeListener(ProgressListener listener) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        listeners.remove(listener);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private synchronized void updateProgress(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (ProgressListener listener: listeners)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;           listener.onProgress(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = 0, total = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] buffer = new byte[1024];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while((n = in.read(buffer)) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                out.write(buffer, 0, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                total += n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                updateProgress(total);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>addListener()</code>, <code>removeListener()</code>, <code>updateProgress()</code>가 모두 동기화되면서
여러개의 스레드가 다른 스레드의 발을 밟지 않고 호출될 수 있습니다.</p><p>문제는 <em>alien method</em>라 불리는 <code>updateProgress()</code> 입니다.
이 메소드는 아무것도 모르고, 다른 락을 요구하는 것을 포함해 모든 것을 할 수 있습니다.
따라서 우리는 두개의 락이 어떤 순서대로 요구해야하는지 알지 못한다는 것입니다.
이것은 우리가 방금 본 데드락을 이끌 수 있습니다.</p><p>유일한 해결 방법은, 락 없이 alien 메소드를 실행하는 것입니다.
이를 위해 <code>listener</code>의 <em>defensive copy</em>를 해야합니다.</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">private void updateProgress(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ArrayList&lt;ProgressListener&gt; listenersCopy; synchronized(this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;       listenersCopy = (ArrayList&lt;ProgressListener&gt;)listeners.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (ProgressListener listener: listenersCopy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        listener.onProgress(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 변경은 일석이조의 효과를 가집니다.
락 없이 alien 메소드를 부를 수 있게 해주고 락을 들고있는 시간을 최소화시켜줍니다.
필요 이상으로 락을 들고있으면 성능 하락과과 데드락의 위험성을 부릅니다.
또한, 이 변경은 동시성과 관련 없는 다른 버그를 고칩니다.
리스너는 <code>removeListener()</code>를 <code>onProgress()</code> 메소드 실행 중에 <code>listner</code>의 복사 없이 호출할 수 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="day1-wrap-up">Day1 Wrap-Up<a class="hash-link" href="#day1-wrap-up" title="Direct link to heading">​</a></h2><p>자바의 멀티스레드의 기초 코드를 다뤘습니다.
다음에서는 더 나은 선택을 제공하는 표준 라이브러리를 살펴볼 것입니다.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="what-we-learned-in-day-1">What We Learned in Day 1<a class="hash-link" href="#what-we-learned-in-day-1" title="Direct link to heading">​</a></h3><p>자바에서 상호 배제 실행을 위해, 모든 자바 객체에 포함된 락을 사용한 스레드를 만드는 법을 다뤘습니다.
또한 스레드와 락에서 세가지 주요 위험인 race conditions, deadlock, and memory visibility를 보았습니다.
그리고 이를 피하기 위한 방법에 대해 논의했습니다.</p><ul><li>Synchronize all access to shared variables.</li><li>Both the writing and the reading threads need to use synchronization.</li><li>Acquire multiple locks in a fixed, global order.</li><li>Don’t call alien methods while holding a lock.</li><li>Hold locks for the shortest possible amount of time.</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="day-1-self-study">Day 1 Self-Study<a class="hash-link" href="#day-1-self-study" title="Direct link to heading">​</a></h3><p>찾아보기  </p><ul><li>Check out William Pugh’s “Java memory model” website.</li><li>Acquaint yourself with the JSR 133 (Java memory model) FAQ.</li><li>What guarantees does the Java memory model make regarding initialization safety? Is it always necessary to use locks to safely publish objects between threads?</li><li>What is the double-checked locking anti-pattern? Why is it an anti-pattern?</li></ul><p>실습<br>
<!-- -->Experiment with the original, broken “dining philosophers” example.
Try modifying the length of time that philosophers think and eat and the number of philosophers.
What effect does this have on how long it takes until deadlock?
Imagine that you were trying to debug this and wanted to increase the likelihood of reproducing the deadlock—what would you do?</p><p>(Hard) Create a program that demonstrates writes to memory appearing to be reordered in the absence of synchronization.
This is difficult because although the Java memory model allows things to be reordered,
most simple examples won’t be optimized to the point of actually demonstrating the problem.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="1java-memory-model"><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4" target="_blank" rel="noopener noreferrer">[1]Java Memory Model</a><a class="hash-link" href="#1java-memory-model" title="Direct link to heading">​</a></h3></div><a href="https://www.buymeacoffee.com/jwher"><img style="margin:20px 0" src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&amp;emoji=&amp;slug=jwher&amp;button_colour=40DCA5&amp;font_colour=ffffff&amp;font_family=Cookie&amp;outline_colour=000000&amp;coffee_colour=FFDD00"></a><footer class="row docusaurus-mt-lg blogPostDetailsFull_enUA"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/en/posts/tags/tech">tech</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/en/posts/tags/distributed-computing">distributed computing</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/jwher/jwher.github.io/posts/2022-12-14-concurrency-models-2/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer><div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/en/posts/concurrency-models-1"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">7가지 동시성 모델 1(소개)</div></a></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#day-1-mutual-exclusion-and-memory-models" class="table-of-contents__link toc-highlight">Day 1: Mutual Exclusion and Memory Models</a><ul><li><a href="#creating-a-thread" class="table-of-contents__link toc-highlight">Creating a Thread</a></li><li><a href="#our-first-lock" class="table-of-contents__link toc-highlight">Our First Lock</a></li><li><a href="#mysterious-memory" class="table-of-contents__link toc-highlight">Mysterious Memory</a></li><li><a href="#memory-visibility" class="table-of-contents__link toc-highlight">Memory Visibility</a></li><li><a href="#multiple-locks" class="table-of-contents__link toc-highlight">Multiple Locks</a></li><li><a href="#the-perils-of-alien-methods" class="table-of-contents__link toc-highlight">The Perils of Alien Methods</a></li></ul></li><li><a href="#day1-wrap-up" class="table-of-contents__link toc-highlight">Day1 Wrap-Up</a><ul><li><a href="#what-we-learned-in-day-1" class="table-of-contents__link toc-highlight">What We Learned in Day 1</a></li><li><a href="#day-1-self-study" class="table-of-contents__link toc-highlight">Day 1 Self-Study</a></li></ul></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a><ul><li><a href="#1java-memory-model" class="table-of-contents__link toc-highlight">[1]Java Memory Model</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">
        <div class="copyright">
          Copyright © 2022, made by JWHer.<span class="heart-icon"></span>
        </div>
        </div></div></div></footer></div>
<script src="/en/assets/js/runtime~main.6d454c49.js"></script>
<script src="/en/assets/js/main.3c483c9e.js"></script>
</body>
</html>